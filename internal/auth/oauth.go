package auth

import (
	"context"
	"crypto/rand"
	"encoding/base64"
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/sschwartz96/syncapod-backend/internal/db"
	protos "github.com/sschwartz96/syncapod-backend/internal/gen"
	"github.com/sschwartz96/syncapod-backend/internal/util"
)

// Scope contains identifiers to oAuth permissions
type Scope string

// Scopes of oauth2.0
const (
	Read       Scope = "Read"
	ReadChange Scope = "ReadChange"
)

// CreateAuthCode creates and saves an authorization code with the client & user id
func (a *AuthController) CreateAuthCode(ctx context.Context, userID uuid.UUID, clientID string) (*db.Authcode, error) {
	key, err := createKey(64)
	if err != nil {
		return nil, fmt.Errorf("CreateAuthorizationCode() error creating key: %v", err)
	}
	code := db.Authcode{
		Code:     key,
		ClientID: clientID,
		UserID:   util.PGUUID(userID),
		Scope:    string(ReadChange),
		Expires:  util.PGFromTime(time.Now().Add(time.Minute * 5)),
	}
	err = a.queries.InsertAuthCode(ctx, db.InsertAuthCodeParams(code))
	if err != nil {
		return nil, fmt.Errorf("AuthController.CreateAuthorizationCode() error inserting auth code: %v", err)
	}
	return &code, nil
}

// CreateAccessToken creates and saves an access token with a year of validity
func (a *AuthController) CreateAccessToken(ctx context.Context, authCode *db.Authcode) (*db.Accesstoken, error) {
	tokenString, err := createKey(64)
	if err != nil {
		return nil, fmt.Errorf("AuthController.CreateAccessToken() error creating access token: %v", err)
	}
	refreshTokenString, err := createKey(64)
	if err != nil {
		return nil, fmt.Errorf("AuthController.CreateAccessToken() error creating access token: %v", err)
	}
	token := db.Accesstoken{
		AuthCode:     authCode.Code,
		Token:        tokenString,
		RefreshToken: refreshTokenString,
		UserID:       authCode.UserID,
		Created:      util.PGFromTime(time.Now()),
		Expires:      3600,
	}
	if err := a.queries.InsertAccessToken(ctx, db.InsertAccessTokenParams(token)); err != nil {
		return nil, fmt.Errorf("AuthController.CreateAccessToken() error inserting access token: %v", err)
	}
	return &token, nil
}

// ValidateAuthCode takes in auth and queries db for
func (a *AuthController) ValidateAuthCode(ctx context.Context, code string) (*db.Authcode, error) {
	decodedCode, err := DecodeKey(code)
	if err != nil {
		return nil, fmt.Errorf("AuthController.ValidateAuthCode() error decoding code: %v", err)
	}
	authCode, err := a.queries.GetAuthCode(ctx, decodedCode)
	if err != nil {
		return nil, fmt.Errorf("AuthController.ValidateAuthCode() error finding auth code: %v", err)
	}
	if authCode.Expires.Time.Before(time.Now()) {
		return nil, fmt.Errorf("AuthController.ValidateAuthCode() error auth code expired")
	}
	return &authCode, nil
}

// ValidateAccessToken takes pointer to dbclient and token string to lookup and validate AccessToken
func (a *AuthController) ValidateAccessToken(ctx context.Context, token string) (*protos.User, error) {
	decodedTkn, err := DecodeKey(token)
	if err != nil {
		return nil, fmt.Errorf("AuthController.ValidateAccessToken() error decoding key: %v", err)
	}
	userAndToken, err := a.queries.GetAccessTokenAndUser(ctx, decodedTkn)
	if err != nil {
		return nil, fmt.Errorf("AuthController.ValidateAccessToken() error finding token: %v", err)
	}
	// if expired
	if time.Now().After(userAndToken.Accesstoken.Created.Time.Add(
		time.Second * time.Duration(userAndToken.Accesstoken.Expires))) {
		return nil, errors.New("AuthController.ValidateAccessToken() error: expired access token")
	}
	userAndToken.User.PasswordHash = []byte{}

	user := a.ConvertUserFromDB(&userAndToken.User)
	return user, nil
}

// ValidateRefreshToken takes in a refresh token, looks up access token and returns it.
// Deletes the access token
// returns error if refresh token is invalid
func (a *AuthController) ValidateRefreshToken(ctx context.Context, token string) (*db.Accesstoken, error) {
	decodedTkn, err := DecodeKey(token)
	if err != nil {
		return nil, fmt.Errorf("AuthController.ValidateRefreshToken() error decoding key: %v", err)
	}

	accesTkn, err := a.queries.GetAccessTokenByRefresh(ctx, decodedTkn)
	if err != nil {
		return nil, fmt.Errorf("AuthController.ValidateRefreshToken() error finding access token: %v", err)
	}

	err = a.queries.DeleteAccessToken(ctx, accesTkn.Token)
	if err != nil {
		a.log.Warn("error deleting access token", util.Err(err))
	}
	return &accesTkn, nil
}

// createKey takes in a key length and returns base64 encoding
// of a crypo-rand generated byte sequence
func createKey(l int) ([]byte, error) {
	key := make([]byte, l)
	_, err := rand.Read(key)
	if err != nil {
		return nil, fmt.Errorf("createKey(): error creating random key: %v", err)
	}
	return key, nil
}

func EncodeKey(key []byte) string {
	return base64.URLEncoding.EncodeToString(key)
}

func DecodeKey(key string) ([]byte, error) {
	return base64.URLEncoding.DecodeString(key)
}
